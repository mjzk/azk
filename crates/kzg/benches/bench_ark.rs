use ark_bls12_377::Bls12_377;
use ark_crypto_primitives::sponge::poseidon::{PoseidonConfig, PoseidonSponge};
use ark_crypto_primitives::sponge::CryptographicSponge;
use ark_ec::pairing::Pairing;
use ark_ff::PrimeField;
use ark_ff::UniformRand;
use ark_poly::Polynomial;
use ark_poly::{univariate::DensePolynomial, DenseUVPolynomial};
use ark_poly_commit::{marlin_pc::MarlinKZG10, LabeledPolynomial, PolynomialCommitment};
use ark_std::test_rng;
use criterion::{criterion_group, criterion_main, Criterion};

type UniPoly377 = DensePolynomial<<Bls12_377 as Pairing>::ScalarField>;
type SpongeBls12_377 = PoseidonSponge<<Bls12_377 as Pairing>::ScalarField>;
type PCS = MarlinKZG10<Bls12_377, UniPoly377, SpongeBls12_377>;

fn test_sponge<F: PrimeField>() -> PoseidonSponge<F> {
    let full_rounds = 8;
    let partial_rounds = 31;
    let alpha: u64 = 17;

    let mds: Vec<Vec<F>> = vec![
        vec![F::one(), F::zero(), F::one()],
        vec![F::one(), F::one(), F::zero()],
        vec![F::zero(), F::one(), F::one()],
    ];

    let mut v = Vec::new();
    let mut ark_rng = test_rng();

    for _ in 0..(full_rounds + partial_rounds) {
        let mut res = Vec::new();

        for _ in 0..3 {
            res.push(F::rand(&mut ark_rng));
        }
        v.push(res);
    }
    let config = PoseidonConfig::new(full_rounds, partial_rounds, alpha, mds, v, 2, 1);
    PoseidonSponge::new(&config)
}

fn bench_kzg_arkworks(c: &mut Criterion) {
    let rng = &mut test_rng();

    let max_degree = 16; // max degree supported by the scheme with the given public parameters generated by the setup here.

    let pp = PCS::setup(max_degree, None, rng).unwrap();

    let degree = 10; //degree of our polynomial
    let secret_poly = UniPoly377::rand(degree, rng);

    let point = <Bls12_377 as Pairing>::ScalarField::rand(rng);

    let label = String::from("secret_poly");
    let labeled_poly = LabeledPolynomial::new(
        label.clone(),
        secret_poly.clone(),
        Some(degree),
        Some(2), // we will open a univariate poly at two points
    );

    let test_sponge = test_sponge::<<Bls12_377 as Pairing>::ScalarField>();

    let (ck, vk) = PCS::trim(&pp, degree, 2, Some(&[degree])).unwrap();

    let (comms, states) = PCS::commit(&ck, [&labeled_poly], Some(rng)).unwrap();

    c.bench_function("KZG(arkworks) commit", |b| {
        b.iter(|| {
            let _ = PCS::commit(&ck, [&labeled_poly], Some(rng)).unwrap();
        })
    });

    let proof = PCS::open(
        &ck,
        [&labeled_poly],
        &comms,
        &point,
        &mut (test_sponge.clone()),
        &states,
        None,
    )
    .unwrap();

    c.bench_function("KZG(arkworks) open", |b| {
        b.iter(|| {
            let _ = PCS::open(
                &ck,
                [&labeled_poly],
                &comms,
                &point,
                &mut (test_sponge.clone()),
                &states,
                None,
            )
            .unwrap();
        })
    });

    assert!(PCS::check(
        &vk,
        &comms,
        &point,
        [secret_poly.evaluate(&point)],
        &proof,
        &mut (test_sponge.clone()),
        Some(rng)
    )
    .unwrap());

    c.bench_function("KZG(arkworks) verify", |b| {
        b.iter(|| {
            assert!(PCS::check(
                &vk,
                &comms,
                &point,
                [secret_poly.evaluate(&point)],
                &proof,
                &mut (test_sponge.clone()),
                Some(rng)
            )
            .unwrap());
        })
    });
}

criterion_group!(benches, bench_kzg_arkworks);
criterion_main!(benches);
